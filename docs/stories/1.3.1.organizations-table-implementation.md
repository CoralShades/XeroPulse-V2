# Story 1.3.1: Implement Organizations Table for Multi-Tenancy

## Status
**Draft**

## Story
**As a** database administrator,
**I want** an organizations table with proper foreign key constraints from all tenant-scoped tables,
**So that** multi-tenant data isolation is enforced at the database level with referential integrity.

## Acceptance Criteria

1. `organizations` table created with UUID primary key and proper column structure
2. Foreign key constraints added from all xero_* tables to organizations table
3. organization_id field type converted from TEXT to UUID in all tables (or FK constraint added to TEXT field)
4. RLS policies updated to use organizations table for tenant isolation
5. Migration file created and version-controlled in `supabase/migrations/`
6. Existing production data migrated to organizations table without data loss
7. All foreign key constraints verified working correctly
8. Database functions/triggers updated to maintain referential integrity

## Tasks / Subtasks

- [ ] **Task 1: Create Organizations Table** (AC: 1)
  - [ ] Create migration file: `supabase/migrations/YYYYMMDD_create_organizations_table.sql`
  - [ ] Define organizations table structure:
    ```sql
    CREATE TABLE organizations (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        name VARCHAR(255) NOT NULL,
        xero_tenant_id VARCHAR(100) UNIQUE,
        xpm_api_key VARCHAR(255),
        subscription_status VARCHAR(20) DEFAULT 'active',
        created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
        updated_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
        xero_connected BOOLEAN DEFAULT false,
        xpm_connected BOOLEAN DEFAULT false,
        last_sync_at TIMESTAMP WITH TIME ZONE
    );
    ```
  - [ ] Add CHECK constraint for subscription_status
  - [ ] Create indexes on xero_tenant_id and subscription_status
  - [ ] Enable RLS on organizations table

- [ ] **Task 2: Migrate Existing Organization Data** (AC: 6)
  - [ ] Extract unique organization_id values from xero_contacts table
  - [ ] Create organization records for each unique organization_id
  - [ ] Map TEXT organization_id to UUID (generate UUID for each unique TEXT id)
  - [ ] Create mapping table for TEXT → UUID conversion if needed
  - [ ] Verify all organization_id values have corresponding organization record

- [ ] **Task 3: Add Foreign Key Constraints** (AC: 2, 3)
  - [ ] Option A: If keeping TEXT organization_id:
    - [ ] Add FK constraint using organization.xero_tenant_id or custom mapping
  - [ ] Option B: If converting to UUID (recommended):
    - [ ] Add organization_uuid column to all xero_* tables
    - [ ] Populate organization_uuid from TEXT→UUID mapping
    - [ ] Add FK constraints: `organization_uuid UUID REFERENCES organizations(id)`
    - [ ] Create migration to rename organization_uuid → organization_id after verification
  - [ ] Tables requiring FK constraints:
    - [ ] xero_invoices
    - [ ] xero_contacts
    - [ ] xero_accounts
    - [ ] xero_bank_transactions
    - [ ] xero_budgets
    - [ ] xero_projects
    - [ ] xero_users
    - [ ] xero_project_time_entries
    - [ ] xero_project_expenses
    - [ ] xero_profit_and_loss_reports
    - [ ] xero_data_cache
    - [ ] profiles
    - [ ] dashboards (if org-scoped)
    - [ ] crm_leads

- [ ] **Task 4: Update RLS Policies** (AC: 4)
  - [ ] Review existing RLS policies
  - [ ] Update policies to reference organizations table
  - [ ] Add policy for organization-level access:
    ```sql
    CREATE POLICY org_isolation ON xero_invoices
    FOR ALL USING (
        organization_id IN (
            SELECT id FROM organizations
            WHERE /* user's org filter */
        )
    );
    ```
  - [ ] Test RLS policies with test users from different organizations
  - [ ] Verify cross-organization data isolation

- [ ] **Task 5: Create Database Functions** (AC: 8)
  - [ ] Create function to get user's organization:
    ```sql
    CREATE FUNCTION get_user_organization_id(user_uuid UUID)
    RETURNS UUID AS $$
        SELECT organization_id FROM profiles WHERE id = user_uuid;
    $$ LANGUAGE sql STABLE;
    ```
  - [ ] Create trigger for updated_at timestamp on organizations
  - [ ] Create function for cascade delete (if needed):
    ```sql
    -- Optional: Function to delete organization and all related data
    CREATE FUNCTION delete_organization_cascade(org_id UUID)
    RETURNS void AS $$
    BEGIN
        -- Delete in correct order to respect FK constraints
        DELETE FROM xero_invoices WHERE organization_id = org_id;
        -- ... other tables
        DELETE FROM organizations WHERE id = org_id;
    END;
    $$ LANGUAGE plpgsql;
    ```

- [ ] **Task 6: Verify Data Integrity** (AC: 7)
  - [ ] Run query to check all xero_* records have valid organization FK:
    ```sql
    SELECT COUNT(*) FROM xero_invoices
    WHERE organization_id NOT IN (SELECT id FROM organizations);
    -- Should return 0
    ```
  - [ ] Test INSERT with invalid organization_id (should fail)
  - [ ] Test DELETE organization with related data (verify CASCADE behavior)
  - [ ] Verify RLS prevents cross-organization data access
  - [ ] Check performance impact of FK constraints on queries

- [ ] **Task 7: Version Control Migration** (AC: 5)
  - [ ] Export schema changes to migration file
  - [ ] Test migration on local development database
  - [ ] Document rollback procedure in migration file
  - [ ] Commit migration to Git: `supabase/migrations/YYYYMMDD_create_organizations_table.sql`
  - [ ] Update migration README with deployment instructions

## Dev Notes

### Architecture Context

**Multi-Tenancy Strategy:**
- Organization-level data isolation is CRITICAL for security and compliance
- All user-facing data must be scoped by organization_id
- Foreign key constraints provide database-level enforcement (vs application-level only)
- Source: `docs/architecture/database-schema.md#multi-tenancy-strategy`

**Current State (Before This Story):**
- organization_id exists as TEXT field in all xero_* tables
- No foreign key constraints → risk of orphaned data
- No organizations table → cannot enforce referential integrity
- RLS policies exist but lack FK validation

**Target State (After This Story):**
- organizations table as master record for all tenants
- All xero_* tables have FK constraints to organizations.id
- Cascade delete behavior defined
- RLS policies leverage organizations table

### Design Decisions

**Primary Key Strategy:**
Recommendation: Use UUID for organizations.id
- Pros: Security (non-guessable), distributed systems friendly, standard PostgreSQL pattern
- Cons: Requires TEXT→UUID migration for existing data

**Alternative**: Keep TEXT organization_id if mapping to xero_tenant_id directly
- Pros: Simpler migration, direct Xero API alignment
- Cons: Less standard, TEXT comparisons slightly slower

**Recommended Approach**: UUID with xero_tenant_id as separate indexed column

### Foreign Key Constraint Options

**CASCADE vs RESTRICT:**
```sql
-- Option 1: RESTRICT (safer, prevents accidental deletion)
FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE RESTRICT

-- Option 2: CASCADE (auto-cleanup, use with caution)
FOREIGN KEY (organization_id) REFERENCES organizations(id) ON DELETE CASCADE
```

**Recommendation**: Use RESTRICT for production. Require explicit organization deletion workflow.

### Migration Strategy

**Zero-Downtime Migration Plan:**
1. Create organizations table
2. Populate with existing organization_id values
3. Add organization_uuid column to all tables (nullable initially)
4. Backfill organization_uuid from TEXT→UUID mapping
5. Add FK constraints (NOT NULL after backfill)
6. Update application code to use organization_uuid
7. Drop old organization_id TEXT column (in future migration)

**Rollback Plan:**
```sql
-- If migration fails, rollback:
ALTER TABLE xero_invoices DROP CONSTRAINT IF EXISTS fk_xero_invoices_org;
DROP TABLE IF EXISTS organizations CASCADE;
```

### Testing

**Testing Standards:**
Infrastructure change requiring comprehensive validation:
- Unit tests: FK constraint enforcement
- Integration tests: Multi-tenant data isolation
- Performance tests: Query performance with FK joins
- Security tests: RLS policy effectiveness

**Test Scenarios:**
1. **FK Constraint Test**: Attempt insert with invalid organization_id → should fail
2. **RLS Test**: User from Org A cannot query data from Org B
3. **Cascade Test**: Delete organization → verify related data handling
4. **Performance Test**: Measure query time before/after FK constraints
5. **Data Integrity Test**: Verify 0 orphaned records after migration

**Validation Queries:**
```sql
-- Check for orphaned records (should return 0 rows)
SELECT table_name, COUNT(*) as orphaned_count
FROM (
    SELECT 'xero_invoices' as table_name, COUNT(*) FROM xero_invoices
    WHERE organization_id NOT IN (SELECT id FROM organizations)
    UNION ALL
    SELECT 'xero_contacts', COUNT(*) FROM xero_contacts
    WHERE organization_id NOT IN (SELECT id FROM organizations)
    -- ... repeat for all tables
) results
WHERE orphaned_count > 0;

-- Verify FK constraints exist
SELECT
    tc.table_name,
    tc.constraint_name,
    tc.constraint_type,
    kcu.column_name
FROM information_schema.table_constraints tc
JOIN information_schema.key_column_usage kcu
    ON tc.constraint_name = kcu.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
AND kcu.column_name = 'organization_id';
```

## Dependencies

**Blocks:**
- Story 1.4-1.9: Proper multi-tenancy required before production deployment
- User management features: Cannot assign users to organizations without this table

**Depends On:**
- Story 1.3: Supabase database schema (completed with xero_* tables)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-30 | 1.0 | Created from QA review findings (Story 1.3 ARCH-002) | Quinn (QA) |

## Implementation Notes

**Estimated Effort**: 4-6 hours
- 1 hour: Create organizations table + populate data
- 2 hours: Add FK constraints to 16 tables
- 1 hour: Update RLS policies
- 1-2 hours: Testing and validation

**Risk Assessment**: Medium
- Risk: FK constraints may fail if orphaned data exists
- Mitigation: Run validation queries before adding constraints, clean data first
- Risk: Performance impact of FK joins
- Mitigation: Benchmark queries, add covering indexes if needed

**Production Deployment**:
1. Schedule during low-traffic window
2. Backup database before migration
3. Run migration with transaction wrapper
4. Verify FK constraints immediately after
5. Monitor query performance for 24 hours
